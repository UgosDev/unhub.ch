# Piano di Deployment per scansioni.ch

Questo documento delinea i passaggi necessari per portare l'applicazione scansioni.ch da un ambiente di sviluppo locale a un ambiente di produzione completo, sicuro e funzionante. Il piano è suddiviso in fasi progressive.

---

## FASE 1: PREPARAZIONE E MESSA IN SICUREZZA (CRUCIALE)

Questa fase affronta i prerequisiti fondamentali per un'applicazione sicura e performante.

### 1.1. Backend Proxy per Chiamate API (Priorità Massima)
- **Problema**: Attualmente, la chiave API di Google Gemini (`process.env.API_KEY`) è destinata ad essere utilizzata nel codice frontend. In un sito pubblico, questa chiave verrebbe esposta a chiunque, permettendo abusi e l'esaurimento del credito a tue spese. **Questa è una vulnerabilità di sicurezza critica.**
- **Soluzione**: Creare un semplice backend "proxy".
    1.  Il frontend non chiamerà più direttamente Google, ma invierà una richiesta al tuo backend (es. `https://api.scansioni.ch/analyze`).
    2.  Il backend riceverà la richiesta, aggiungerà la chiave API segreta (che risiede solo sul server) e inoltrerà la chiamata a Google Gemini.
    3.  Il backend riceverà la risposta da Google e la restituirà al frontend.
- **Implementazione**: Questo può essere fatto facilmente con una funzione serverless (es. Vercel Functions, Netlify Functions, AWS Lambda) per mantenere bassi i costi.

### 1.2. Implementazione di un Build System di Produzione
- **Problema**: L'app si basa su `importmap` e `esm.sh`, ottimi per lo sviluppo ma non per la produzione. Mancano ottimizzazioni cruciali come minificazione, tree-shaking e bundling.
- **Soluzione**: Adottare un bundler moderno come **Vite** o **Webpack**.
    1.  Configurare un progetto Vite (scelta consigliata per la sua velocità e semplicità).
    2.  Creare un file `.env` per le variabili d'ambiente pubbliche (come `VITE_GOOGLE_CLIENT_ID`). La chiave API di Gemini andrà nel backend (vedi punto 1.1).
    3.  Il comando `vite build` creerà una cartella `dist/` con file HTML, CSS e JS ottimizzati, pronti per essere distribuiti.

### 1.3. Revisione Legale
- **Problema**: I file `TermsOfServicePage.tsx` e `PrivacyPolicyPage.tsx` contengono testo segnaposto.
- **Soluzione**: Far revisionare i contenuti da un consulente legale per assicurarsi che siano conformi alle normative svizzere (LPD) e internazionali (GDPR).

---

## FASE 2: DEPLOYMENT E INFRASTRUTTURA INIZIALE

Una volta completata la Fase 1, l'applicazione è pronta per essere messa online.

### 2.1. Scelta e Configurazione dell'Hosting
- **Soluzione**: Utilizzare un provider di hosting per siti statici che si integri con un repository Git.
    1.  **Provider Consigliati**: **Vercel** o **Netlify**. Entrambi offrono piani gratuiti generosi, CDN globali, e integrazione CI/CD automatica.
    2.  Creare un repository Git (es. su GitHub).
    3.  Collegare il repository al provider di hosting scelto.
    4.  Configurare il comando di build (`vite build`) e la cartella di output (`dist`).

### 2.2. Configurazione del Dominio
1.  Acquistare il dominio `scansioni.ch`.
2.  Configurare i record DNS (solitamente un record A o CNAME) per puntare al servizio di hosting scelto (Vercel/Netlify forniranno le istruzioni).
3.  Configurare l'HTTPS (generalmente automatico e gratuito con questi provider).

### 2.3. Configurazione Google Cloud Console
- **Problema**: L'ID Cliente di Google Drive (`GOOGLE_CLIENT_ID`) è autorizzato solo per `localhost`.
- **Soluzione**:
    1.  Andare sulla Google Cloud Console.
    2.  Nella sezione "Credenziali", modificare l'ID cliente OAuth 2.0.
    3.  Aggiungere `https://scansioni.ch` alle "Origini JavaScript autorizzate".

### 2.4. Implementazione di una Pipeline CI/CD
- **Problema**: I deployment manuali sono lenti e soggetti a errori.
- **Soluzione**: Vercel e Netlify lo fanno automaticamente. Ogni volta che si effettua un push sul branch `main` del repository Git, il provider eseguirà automaticamente il build e il deploy della nuova versione.

---

## FASE 3: ATTIVAZIONE FUNZIONALITÀ BACKEND-DEPENDENT

Queste funzionalità sono attualmente simulate e richiedono un'infrastruttura backend per funzionare realmente.

### 3.1. Attivazione Importazione via Email
- **Problema**: `EmailImportView.tsx` è una simulazione.
- **Soluzione**:
    1.  Utilizzare un servizio di ricezione email come **SendGrid Inbound Parse**, **Mailgun Routes** o **AWS SES**.
    2.  Configurare il servizio per inoltrare le email in arrivo a un webhook sul nostro backend (la stessa funzione serverless della Fase 1.1 può essere espansa).
    3.  La funzione backend processerà gli allegati.
    4.  Per notificare il frontend in tempo reale, si può usare una connessione **WebSocket** o **Server-Sent Events**.

### 3.2. Integrazione Pagamenti
- **Problema**: L'acquisto di ScanCoin e la gestione degli abbonamenti sono simulati.
- **Soluzione**: Integrare un sistema di pagamento come **Stripe** per gestire le transazioni in modo sicuro.

---

## STATO ATTUALE: FUNZIONALITÀ COMPLETATE

- **Firebase Authentication**: Il sistema di autenticazione è completo e funzionante, gestendo login, registrazione e sessioni utente in modo sicuro.
- **Firebase Firestore**: Il database locale (IndexedDB) è stato sostituito con Firestore, garantendo la persistenza e la sincronizzazione dei dati utente (scansioni, storico, chat) tra dispositivi.

---

## FASE 4: OTTIMIZZAZIONE E SCALABILITÀ (POST-LANCIO)

### 4.1. Monitoring e Error Tracking
- Integrare un servizio come **Sentry** o **LogRocket** per catturare e analizzare gli errori che si verificano in produzione.

### 4.2. Ottimizzazione delle Performance
- Analizzare regolarmente le performance con Google Lighthouse.
- Ottimizzare le immagini e considerare l'uso di un CDN dedicato se necessario.

### 4.3. SEO per le Pagine Pubbliche
- Assicurarsi che `LandingPage.tsx`, `PricingPage.tsx`, ecc., abbiano meta tag (title, description) appropriati per una corretta indicizzazione sui motori di ricerca.